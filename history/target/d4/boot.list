     1                                  ORG   0x7c00          ; 引导区加载位置
     2                                                        ; 与之相对的详细内存分区可参考 http://www.bioscentral.com/misc/bda.htm
     3                                  
     4                                  ;--------------------------------------- FAT12 格式描述 ------------------------------------------
     5                                  ; FAT12 引导扇区格式参见 http://blog.sina.com.cn/s/blog_3edcf6b80100cr08.html
     6 00000000 EB3C                    jmp entry
     7 00000002 90                      nop
     8                                  %include "fat12.asm"
     9                              <1> ; -----------------------------------------------------------------------------------------------
    10                              <1> ; fat12.asm
    11                              <1> ; - 这个文件描述了一个标准FAT12的开头
    12                              <1> ; - 需要注意的是，在引用本文件前，需要有额外的两行
    13                              <1> ; - jmp (short) entry   指定入口
    14                              <1> ; - nop                 null operation
    15                              <1> ; -----------------------------------------------------------------------------------------------
    16 00000003 414E4F5349504C20    <1> FAT12_OEMName      db    "ANOSIPL "      ; OEM字符串，8字节（通常为格式化本磁盘的操作系统名称及版本）
    17 0000000B 0002                <1> FAT12_BytesPerSec  dw    512             ; 每个扇区(sector)大小，必须为512(B)
    18 0000000D 01                  <1> FAT12_SecPerClus   db    1               ; 簇(cluster)的大小，必须为1（个扇区）
    19 0000000E 0100                <1> FAT12_RsvdSecCnt   dw    1               ; Boot记录所占用的扇区数
    20 00000010 02                  <1> FAT12_NumFATs      db    2               ; FAT的个数（必须为2）
    21 00000011 E000                <1> FAT12_RootEntCnt   dw    224             ; 根目录的文件数最大值（一般设成224项）
    22 00000013 400B                <1> FAT12_TotSec16     dw    2880            ; 该磁盘的大小,即逻辑扇区总数（必须设成2880扇区，即1440KB）
    23 00000015 F0                  <1> FAT12_Media        db    0xf0            ; 磁盘的种类/媒体描述符（必须为F0）
    24 00000016 0900                <1> FAT12_SecPerFAT    dw    9               ; 每个FAT的长度（必须是9扇区）
    25 00000018 1200                <1> FAT12_SecPerTrk    dw    18              ; 每个磁道的扇区数（必须是18）
    26 0000001A 0200                <1> FAT12_NumHeads     dw    2               ; 磁头数（必须是2）
    27 0000001C 00000000            <1> FAT12_HiddSec      dd    0               ; 隐藏扇区数
    28 00000020 400B0000            <1> FAT12_TolSec32     dd    2880            ; 如果BPB_TotSec16是0，则在这里记录扇区总数
    29 00000024 00                  <1> FAT12_DrvNum       db    0               ; 中断13的驱动器号
    30 00000025 00                  <1> FAT12_Reserved1    db    0               ; 保留字段
    31 00000026 29                  <1> FAT12_BootSig      db    29h             ; 扩展引导标记(29h)
    32 00000027 00000000            <1> FAT12_VolID        dd    0               ; 卷序列号
    33 0000002B 416E204F5320416C70- <1> FAT12_VolLbl       db    "An OS Alpha"   ; 卷标（11字节）
    34 00000034 6861                <1>
    35 00000036 4641543132202020    <1> FAT12_FilsSysType  db    "FAT12   "      ; 文件系统类型（8字节）
    36                              <1> 
    37                              <1> ; ------------------------------------------------------------------------------------------------
    38                              <1> ; 一些基于FAT12头的常量定义
    39                              <1> ; ------------------------------------------------------------------------------------------------
    40                              <1> 
    41                              <1> CFAT12_SecPerFAT         equ   9
    42                              <1> CFAT12_RootSectors       equ   14
    43                              <1> CFAT12_SecNoOfRoot       equ   19
    44                              <1> CFAT12_SecNoOfFAT1       equ   1
    45                              <1> CFAT12_DeltaSecNo        equ   17
    46                              <1> CFAT12_RootEntCnt        equ   224
    47                              <1> 
    48                              <1> CFAT12_RootItemLen       equ   32
    49                                  ; ----------------------------------------- 常量定义 ---------------------------------------------
    50                                  StackBaseAddr    equ 0x0800
    51                                  KernelBaseAddr   equ 0x1000
    52                                  KernelOffsetAddr equ 0x0000
    53                                  
    54                                  ;------------------------------------------ 程序主体 ---------------------------------------------
    55                                  ; BIOS中断表参见 http://www.cnblogs.com/walfud/articles/2980774.html
    56                                  entry:
    57 0000003E BA[2601]                  mov dx, LoadStr
    58 00000041 E83D00                    call dispstr                                    ; 显示提示信息
    59                                    ; 载入根目录文件表
    60 00000044 BC0008                    mov sp, StackBaseAddr                           ; stack initialization
    61 00000047 B80010                    mov ax, KernelBaseAddr                          ; 设置数据缓冲基地址
    62 0000004A 8EC0                      mov es, ax
    63 0000004C BB0000                    mov bx, KernelOffsetAddr                        ; 设置数据缓冲偏移
    64 0000004F B81400                    mov ax, 20                                      ; 1 - boot sector, 2 - 9, 10 - 18 : FAT
    65                                                                                    ; todo why 20/19 ???????
    66 00000052 B90E00                    mov cx, CFAT12_RootEntCnt*32/512                ; number of sectors
    67 00000055 E88000                    call readsec
    68 00000058 BA[3B01]                  mov dx, RootStr
    69 0000005B E82300                    call dispstr
    70 0000005E BA0010                    mov dx, KernelBaseAddr
    71 00000061 83C220                    add dx, CFAT12_RootItemLen
    72 00000064 E81A00                    call dispstr
    73                                  
    74 00000067 BA0010                    mov dx, KernelBaseAddr
    75 0000006A 8EDA                      mov ds, dx
    76 0000006C BA0000                    mov dx, KernelOffsetAddr
    77 0000006F 83C220                    add dx, CFAT12_RootItemLen
    78 00000072 E80C00                    call dispstr
    79 00000075 EB00                      jmp fin
    80                                  
    81                                  fin:                          ; 程序结束
    82 00000077 F4                        hlt
    83 00000078 E9(00C4)                  jmp 0xc400                  ; 跳入app.sys
    84                                                                ; todo 为什么跳转地址是这个?
    85                                                                ; 原书所述地址是0xc200，然而实际上由于计算机顺序向后执行命令，因此只
    86                                                                ; 要在跳转地址和实际地址之间没有多余的jmp指令，就可以正常运行。但是
    87                                                                ; 若跳转地址大于实际地址则无法正常执行
    88                                  
    89                                  %include "display.asm"
    90                              <1> ; ---------------------------- 显示信息：公用代码 ------------------------------------------------
    91                              <1> 
    92                              <1> ; dispinit
    93                              <1> dispinit:
    94 0000007B C606[D700]01        <1>   mov byte [Offset], 0x01
    95 00000080 C3                  <1>   ret
    96                              <1> 
    97                              <1> ; dispstr
    98                              <1> ; - dx 在屏幕显示起始位置为sp:dx的字符串
    99                              <1> dispstr:
   100 00000081 50                  <1>   push ax                     ; NOTE these registers must be stored !!!!!!!!!!!!!!!!!!!!!!!!!!
   101 00000082 53                  <1>   push bx
   102 00000083 51                  <1>   push cx
   103 00000084 89D6                <1>   mov si, dx
   104                              <1> 
   105                              <1> dispstr_loop:
   106 00000086 3E8A04              <1>   mov al, [ds:si]
   107 00000089 3C00                <1>   cmp al, 0
   108 0000008B 7433                <1>   je dispstr_end              ; 若AL = 0 则停止工作. 此处若改为JE entry则可无限向屏幕写入字符串
   109 0000008D 3C0A                <1>   cmp al, 0x0a                ; if AL = 0x0a, we need an endl
   110 0000008F 740E                <1>   je dispstr_endl_found  
   111                              <1>   dispstr_printchr:
   112 00000091 B301                <1>     mov bl, 01                  ; 选择前景色。不过不切换显示模式的话貌似无用
   113 00000093 B40E                <1>     mov ah, 0x0e                ; 选择中断功能：显示字符并后移光标
   114 00000095 CD10                <1>     int 0x10                    ; 调用显示中断
   115                              <1>   dispstr_endl_finish:
   116 00000097 83C601              <1>     add si, 1
   117 0000009A E81000              <1>     call dispstr_offsetinc
   118 0000009D EBE7                <1>     jmp dispstr_loop
   119                              <1> 
   120                              <1> dispstr_endl_found:
   121 0000009F 803E[D700]00        <1>   cmp byte [Offset], 0
   122 000000A4 74F1                <1>   je dispstr_endl_finish      ; we already have an endline
   123 000000A6 B020                <1>   mov al, ' '
   124 000000A8 83EE01              <1>   sub si, 1
   125 000000AB EBE4                <1>   jmp dispstr_printchr
   126                              <1> 
   127                              <1> dispstr_offsetinc:
   128 000000AD 8006[D700]01        <1>   add byte [Offset], 1
   129 000000B2 803E[D700]51        <1>   cmp byte [Offset], 81
   130 000000B7 7401                <1>   je dispstr_offsetreset
   131 000000B9 C3                  <1>   ret
   132                              <1>   dispstr_offsetreset:
   133 000000BA C606[D700]00        <1>     mov byte [Offset], 0        ; todo find out why 0 works here ?
   134 000000BF C3                  <1>     ret
   135                              <1> 
   136                              <1> dispstr_end:
   137 000000C0 59                  <1>   pop cx
   138 000000C1 5B                  <1>   pop bx
   139 000000C2 58                  <1>   pop ax
   140 000000C3 C3                  <1>   ret
   141                              <1> 
   142                              <1> dispdebug:
   143 000000C4 53                  <1>   push bx
   144 000000C5 50                  <1>   push ax
   145 000000C6 51                  <1>   push cx
   146 000000C7 52                  <1>   push dx
   147 000000C8 88E8                <1>   mov al, ch                   ; show debug information
   148 000000CA 0430                <1>   add al, 0x30
   149 000000CC B301                <1>   mov bl, 01
   150 000000CE B40E                <1>   mov ah, 0x0e
   151 000000D0 CD10                <1>   int 0x10
   152 000000D2 5A                  <1>   pop dx
   153 000000D3 59                  <1>   pop cx
   154 000000D4 58                  <1>   pop ax
   155 000000D5 5B                  <1>   pop bx
   156 000000D6 C3                  <1>   ret
   157                              <1> 
   158                              <1> ; --------------------------------- data segment of video ----------------------------------------
   159 000000D7 01                  <1> Offset db 1
   160                                  %include "floppy.asm"
   161                              <1> ; 这个文件是用来存放软盘读写的 API
   162                              <1> ; http://blog.csdn.net/littlehedgehog/article/details/2147361
   163                              <1> 
   164                              <1> ; 中断13，AH = 2 - 读取
   165                              <1> ; 读磁盘
   166                              <1> ;   AL=扇区数
   167                              <1> ;   CH,CL=磁盘号,扇区号
   168                              <1> ;   DH,DL=磁头号,驱动器号
   169                              <1> ;   ES:BX=数据缓冲区地址  
   170                              <1> ; Return Value
   171                              <1> ;   读成功:AH=0
   172                              <1> ;   AL=读取的扇区数
   173                              <1> ;   读失败:AH=出错代码
   174                              <1> 
   175                              <1> ; readsec 读逻辑扇区
   176                              <1> ; AX 起始扇区
   177                              <1> ; CX 待读个数
   178                              <1> ; ES:BX 数据缓冲区地址
   179                              <1> readsec:
   180 000000D8 51                  <1>   push cx
   181 000000D9 53                  <1>   push bx                             ; since bx is used in following lines, we need to store its
   182                              <1>                                       ; value temporarily
   183 000000DA 8A1E[1800]          <1>   mov bl, [FAT12_SecPerTrk]
   184 000000DE F6F3                <1>   div bl                              ; AX % BL = AH, AX / BL = AL
   185 000000E0 5B                  <1>   pop bx
   186 000000E1 88C6                <1>   mov dh, al                          ; 求磁头号
   187 000000E3 80E601              <1>   and dh, 0x01                        ; 若是偶数，则磁头号为0，否则为1
   188 000000E6 D0E8                <1>   shr al, 1
   189 000000E8 88C5                <1>   mov ch, al                          ; 柱面号 or 磁道号 
   190 000000EA 88E1                <1>   mov cl, ah                          ; 起始扇区号
   191 000000EC 8A16[2400]          <1>   mov dl, [FAT12_DrvNum]
   192 000000F0 58                  <1>   pop ax                              ; 将待读个数CX弹到AX中，用AX为计数器
   193                              <1> 
   194                              <1> readsec_loop:
   195 000000F1 50                  <1>   push ax
   196 000000F2 B001                <1>   mov al, 1                           ; 每次只读1个扇区
   197 000000F4 B402                <1>   mov ah, 2                           ; 设定为读取磁盘模式
   198                              <1>   tryread:
   199                              <1>     ; call dispdebug                  ; dispdebug函数用来输出调试信息
   200 000000F6 CD13                <1>     int 0x13
   201 000000F8 72FC                <1>     jc tryread                        ; 若失败则重新读取
   202 000000FA 58                  <1>   pop ax
   203 000000FB 81C30002            <1>   add bx, 512                         ; 指针向后一个扇区
   204 000000FF E80A00              <1>   call readsec_secinc                 ; 扇区自增
   205 00000102 83E801              <1>   sub ax, 1                           ; 计数器 -1
   206 00000105 83F800              <1>   cmp ax, 0
   207 00000108 741B                <1>   je readsec_end
   208 0000010A EBE5                <1>   jmp readsec_loop
   209                              <1> 
   210                              <1> ; 子函数，使得逻辑扇区+1并计算对应的柱面-磁头-扇区表示
   211                              <1> readsec_secinc:
   212 0000010C 80C101              <1>   add cl, 1
   213 0000010F 80F913              <1>   cmp cl, 19
   214 00000112 7510                <1>   jne readsec_secinc_end              ; 若扇区号尚不足19，自增后可直接退出
   215                              <1>                                       ; 扇区范围为 1-19 [重要!!!!!!!!!!!!!!!!!]
   216 00000114 B101                <1>     mov cl, 1                         ; 否则变化磁头号
   217 00000116 80FE00              <1>     cmp dh, 0                         ; 若磁头号为0, 则磁道号加1
   218 00000119 7504                <1>     jne readsec_secinc_cyninc         ; 若磁头号已经为1, 则磁道号清零并增加柱面号
   219 0000011B B601                <1>     mov dh, 1                         ; 若磁头号尚未0, 则磁道号+1并退出
   220 0000011D EB05                <1>     jmp readsec_secinc_end
   221                              <1>   readsec_secinc_cyninc:              ; 柱面号需+1
   222 0000011F B600                <1>     mov dh, 0
   223 00000121 80C501              <1>     add ch, 1
   224                              <1>   readsec_secinc_end:
   225 00000124 C3                  <1>     ret
   226                              <1> 
   227                              <1> readsec_end:
   228 00000125 C3                  <1>   ret
   229                              <1> 
   230                                  
   231                                  ; ---------------------------------------- 数据段 ------------------------------------------------
   232 00000126 4C6F6164696E672046-     LoadStr     db "Loading Floppy ... ", 0x0a, 0x00
   233 0000012F 6C6F707079202E2E2E-
   234 00000138 200A00             
   235 0000013B 526F6F742044697265-     RootStr     db "Root Directory Loaded.", 0x0a, 0x00
   236 00000144 63746F7279204C6F61-
   237 0000014D 6465642E0A00       
   238 00000153 205B444F4E455D00        FinishFlag  db " [DONE]", 0x00
   239                                  
   240 0000015B 00<rept>                TIMES (0x01FE-($-$$)) db 0    ; 填充当前扇区。不知道为何原文给定的填充结束位置为0x7dfe
   241                                                                ; 不过这个填充位置显然是错的，因为这样55AA标志便远在引导扇区之外
   242                                                                ; 因此我们将填充位置改为 0x01FE，因为 0x01FE + 2 = 0x0200恰好为
   243                                                                ; 第一个扇区的长度
   244 000001FE 55AA                    DB    0x55, 0xaa
