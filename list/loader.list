     1                                  ; ----------------------------------------- 常量定义 ---------------------------------------------
     2                                  %include "memorymap.asm"
     3                              <1> ; ------------------------------------------------------------------------------------------------
     4                              <1> ; memorymap.asm
     5                              <1> ; - all base addreses and offsets are defined in this section
     6                              <1> ; ------------------------------------------------------------------------------------------------
     7                              <1> 
     8                              <1> ; ----------------------------------------- 内存区划 ---------------------------------------------
     9                              <1> ; 0x0000 - 0x7c00 系统预留
    10                              <1> ; 0x7c00 - 0x7e00 引导扇区
    11                              <1> ; 0x7e00 - 0x8000 堆栈(512 Byte)
    12                              <1> ; 0x8000 - 0x9200 FAT(512 Byte * 9)
    13                              <1> ; 0x9200 - 0x9A00 Loader.bin
    14                              <1> ; 0x9A00 -        Kernel.bin
    15                              <1> 
    16                              <1> ; todo need rewrite !!!!!!!!!!
    17                              <1> 
    18                              <1> SectorSize            equ 0x0200
    19                              <1> 
    20                              <1> BootLoaderOffsetAddr  equ 0x7c00
    21                              <1> 
    22                              <1> StackBaseAddr         equ 0x0000
    23                              <1> StackOffsetAddr       equ 0x7e00                    ; 0x7c00 + SectorSize
    24                              <1> FATBaseAddr           equ 0x8000                    ; 0x80000
    25                              <1> FATOffsetAddr         equ 0x0000
    26                              <1> LoaderBaseAddr        equ 0x81c0                    ; FATBaseAddr + SectorSize * 14 / 0x000F
    27                              <1> LoaderOffsetAddr      equ 0x0000
    28                              <1> KernelBaseAddr        equ 0x8240                    ; LoaderBaseAddr + SectorSize * 4 / 0x000F
    29                              <1> KernelOffsetAddr      equ 0x0000
    30                              <1> 
    31                              <1> Stack32BaseAddr       equ 0x00010000
    32                              <1> Kernel32SegBaseAddr   equ 0x00020000                ; Kernel in 32 bit would be located outside 1MB
    33                                  ; ------------------------------------------ 程序主体 --------------------------------------------
    34                                  ; 
    35                                  org   LoaderOffsetAddr
    36                                  ;--------------------------------------- FAT12 格式描述 ------------------------------------------
    37                                  ; FAT12 引导扇区格式参见 http://blog.sina.com.cn/s/blog_3edcf6b80100cr08.html
    38                                  [section .text]
    39                                  [bits 16]
    40                                  
    41 00000000 E82202                  call screen_reset                                                     ; 重设屏幕
    42                                  
    43 00000003 B8C081                  mov ax, LoaderBaseAddr
    44 00000006 BB[2E00]                mov bx, LoaderReadyStr
    45 00000009 E85801                  call printstr
    46                                  
    47                                  ; 指定输入文件地址
    48 0000000C B8C081                  mov ax, LoaderBaseAddr
    49 0000000F 8ED8                    mov ds, ax
    50 00000011 B8[9300]                mov ax, KernelName
    51 00000014 BB4082                  mov bx, KernelBaseAddr
    52 00000017 B90000                  mov cx, KernelOffsetAddr
    53 0000001A E84100                  call loadfile
    54                                  
    55                                  ; 检查内核载入状况
    56 0000001D 80FC00                  cmp ah, 0
    57 00000020 752F                    jne failed_loadingkernel
    58                                  
    59                                  ; 内核载入完成
    60 00000022 8CC8                    mov ax, cs
    61 00000024 BB[6300]                mov bx, KernelReadyStr
    62 00000027 E83A01                  call printstr
    63                                  
    64 0000002A 8CC8                    mov ax, cs
    65 0000002C BB[6A00]                mov bx, ProtectedModeIn
    66 0000002F E83201                  call printstr
    67                                  
    68                                  ; prepare for protected mode
    69                                  
    70 00000032 2E0F0116[2800]          lgdt [cs:gdtr]                                     ; load gdt
    71                                  
    72 00000038 FA                      cli                                                ; disable interruptions
    73                                  
    74 00000039 E492                    in al, 92h                                         ; open A20 bus
    75 0000003B 0C02                    or al, 10b
    76 0000003D E692                    out 92h, al
    77                                  
    78 0000003F 0F20C0                  mov eax, cr0                                       ; make cpu working in protected mode
    79 00000042 6683C801                or eax, 1
    80 00000046 0F22C0                  mov cr0, eax
    81                                  
    82                                  ; jump to protected mode
    83 00000049 66EA[82020000]1000      jmp dword gdtselector_loader32seg:LoaderOffsetAddr + entry32
    84                                  
    85                                  
    86                                  ; --------------------------------------- fail locations ----------------------------------------
    87                                  failed_loadingkernel:
    88 00000051 B8C081                    mov ax, LoaderBaseAddr
    89 00000054 BB[8B00]                  mov bx, FailLoadingStr
    90 00000057 EB00                      jmp failed
    91                                    
    92                                  failed:
    93 00000059 E80801                    call printstr
    94 0000005C EBFE                      jmp $
    95                                  
    96                                  ; --------------------------------------- import libraries ---------------------------------------
    97                                  %include "floppy.asm"
    98                              <1> ; debug
    99                              <1> ;printdebugsym:
   100                              <1>   ;push bx
   101                              <1>   ;push ax
   102                              <1>   ;mov bl, 0
   103                              <1>   ;mov ah, 0x0E
   104                              <1>   ;mov al, bh
   105                              <1>   ;add al, 0x30
   106                              <1>   ;int 0x10
   107                              <1>   ;mov al, bl
   108                              <1>   ;add al, 0x30
   109                              <1>   ;int 0x10
   110                              <1>   ;mov al, '/'
   111                              <1>   ;int 0x10
   112                              <1>   ;pop ax
   113                              <1>   ;pop bx
   114                              <1>   ;ret
   115                              <1> 
   116                              <1> ; 这个文件是用来存放软盘读写的 API
   117                              <1> ; http://blog.csdn.net/littlehedgehog/article/details/2147361
   118                              <1> 
   119                              <1> ; 输入参数:
   120                              <1> ; AX - 待载入文件的文件名（前8位）地址（所在位置）
   121                              <1> ; BX - 将要载入到的位置段
   122                              <1> ; CX - 将要载入到的位置偏移
   123                              <1> 
   124                              <1> ; 返回值 - AH = 0 (正确载入)
   125                              <1> ; AH = 1 (出现错误)
   126                              <1> loadfile:
   127                              <1>   ; 载入根目录文件表
   128 0000005E 51                  <1>   push cx
   129 0000005F 53                  <1>   push bx
   130 00000060 50                  <1>   push ax
   131 00000061 B80080              <1>   mov ax, FATBaseAddr                             ; 设置数据缓冲基地址
   132 00000064 8EC0                <1>   mov es, ax
   133 00000066 BB0000              <1>   mov bx, FATOffsetAddr                           ; 设置数据缓冲偏移
   134 00000069 B81300              <1>   mov ax, CFAT12_SecNoOfRoot                      ; 0 - boot sector, 1 - 9/10 - 18 : FAT1/2
   135 0000006C B90E00              <1>   mov cx, CFAT12_RootSectors                      ; number of sectors
   136 0000006F E89E00              <1>   call readsec                                    ; obtain the root directory items
   137                              <1>   ; 根目录载入完毕
   138                              <1>   ; 接下来查找根目录中的全部224项，检查是否存在指定名称的字符串
   139 00000072 BA0000              <1>   mov dx, FATOffsetAddr
   140 00000075 83EA20              <1>   sub dx, CFAT12_RootItemLen
   141 00000078 89D6                <1>   mov si, dx
   142 0000007A C606[6301]E0        <1>   mov byte [MaxItem], CFAT12_RootEntCnt           ; maximal iteration limit
   143                              <1> 
   144                              <1> ; 查找Loader
   145                              <1> ; 过程中，es:si始终指向当前根目录项的首位值
   146                              <1> ; 首先我们将文件名地址出到di处
   147 0000007F 5F                  <1>   pop di 
   148                              <1> 
   149                              <1> search_file:
   150 00000080 83C620              <1>   add si, CFAT12_RootItemLen                      ; jump to next item
   151 00000083 802E[6301]01        <1>   sub byte [MaxItem], 1                           ; decrease the limit counter
   152 00000088 803E[6301]00        <1>   cmp byte [MaxItem], 0
   153 0000008D 7452                <1>   je loader_loader_fail                           ; we have meet the limit
   154 0000008F 3E668B05            <1>   mov eax, [ds:di]
   155 00000093 26663904            <1>   cmp dword [es:si], eax                          ; compare first 4 chars
   156 00000097 75E7                <1>   jne search_file                                 ; 如果不相同，则说明前4位不符
   157 00000099 3E668B4504          <1>   mov eax, [ds:di+4]
   158 0000009E 2666394404          <1>   cmp dword [es:si+4], eax
   159 000000A3 75DB                <1>   jne search_file
   160                              <1> 
   161                              <1> ; 若找到文件，则马上从项目中取出相应的首簇号
   162                              <1> save_clusterNo:
   163 000000A5 268B441A            <1>   mov ax, [es:si + 26]                            ; no. cluster is located with an offset 26
   164 000000A9 50                  <1>   push ax                                         ; put the cluster no. in the stack in case it
   165                              <1>                                                   ; probably be rewritten by readsec
   166                              <1>   ; mov eax, [ds:si + 28]                         ; filelength, currently not used
   167                              <1> 
   168                              <1> 
   169                              <1> load_FileAllocationTable:                         ; match found in DS:DX
   170 000000AA BB0000              <1>   mov bx, FATOffsetAddr
   171 000000AD B80100              <1>   mov ax, CFAT12_SecNoOfFAT1                      ; we're going to load the first FAT
   172 000000B0 B90900              <1>   mov cx, CFAT12_SecPerFAT
   173 000000B3 E85A00              <1>   call readsec
   174                              <1> 
   175                              <1> load_filebody:                                    ; we need to locate the kernel through FAT
   176 000000B6 8CC0                <1>   mov ax, es
   177 000000B8 8EE8                <1>   mov gs, ax                                      ; put the base address of FAT to gs
   178 000000BA 58                  <1>   pop ax                                          ; 恢复簇号
   179 000000BB 5B                  <1>   pop bx                                          ; initialize base address of loader.bin (line 7)
   180 000000BC 8EC3                <1>   mov es, bx
   181 000000BE 5B                  <1>   pop bx                                          ; initialize offset address of loader.bin
   182                              <1>   load_loader_loop:
   183                              <1>     ; we should check the cluster number FIRSTLY
   184 000000BF 3DF80F              <1>     cmp ax, 0x0ff8                                ; if 0x0ff0 <= successor <= 0x0ff7, the cluster is
   185                              <1>                                                   ; broken and should not be used
   186 000000C2 731A                <1>     jnb loader_loader_fin
   187 000000C4 3DF00F              <1>     cmp ax, 0x0ff0                                ; successor < 0x0ff0, that's good sectors
   188 000000C7 7318                <1>     jnb loader_loader_fail                           ; continue reading
   189                              <1>     ; obtain the current cluster
   190 000000C9 83C01F              <1>     add ax, CFAT12_SecNoClstZero                  ; cluster no. -> sector no.
   191 000000CC B90100              <1>       mov cx, 1                                   ; one cluster, one time (very important)
   192 000000CF E83E00              <1>       call readsec                                ; read one sector as a cluster
   193 000000D2 81C30002            <1>       add bx, CFAT12_BytesPerSec                  ; move the address pointer
   194 000000D6 83E81F              <1>     sub ax, CFAT12_SecNoClstZero                  ; sector no. -> cluster no. before continuing
   195 000000D9 E80A00              <1>     call nextcluster                              ; find the index of the successing cluster
   196 000000DC EBE1                <1>     jmp load_loader_loop
   197                              <1> 
   198                              <1>   loader_loader_fin:
   199                              <1>     ; otherwise we have finished kernel loading
   200 000000DE B400                <1>     mov ah, 0
   201 000000E0 C3                  <1>     ret
   202                              <1> 
   203                              <1>   loader_loader_fail:        ; NO Kernels Found !!!!!!
   204 000000E1 B401                <1>     mov ah, 1                ; 设置返回值
   205 000000E3 5B                  <1>     pop bx                   ; [重要] 在任意一个返回过程中都要正确清理堆栈
   206 000000E4 59                  <1>     pop cx
   207 000000E5 C3                  <1>     ret
   208                              <1>     
   209                              <1> ; suppose AX stores the index of current cluster
   210                              <1> ; *nextcluster* generates the successor cluster index, stored in AX
   211                              <1> nextcluster:
   212 000000E6 56                  <1>   push si                                         ; put two registers in stack
   213 000000E7 53                  <1>   push bx
   214 000000E8 88C1                <1>   mov cl, al
   215 000000EA 80E101              <1>   and cl, 1                                       ; CL = AX % 2 = 0 / 1
   216 000000ED D1E8                <1>   shr ax, 1                                       ; AX /= 2
   217 000000EF 89C3                <1>   mov bx, ax
   218 000000F1 D1E0                <1>   shl ax, 1                                       ; AX = 3 * AX
   219 000000F3 01D8                <1>   add ax, bx
   220 000000F5 89C6                <1>   mov si, ax                                      ; SI set to the offset of current 3-byte
   221 000000F7 B500                <1>   mov ch, 0                                       ; let CX = CL
   222 000000F9 01CE                <1>   add si, cx                                      ; CX == 0 - pick up the first two bytes, otherwise
   223                              <1>                                                   ; the last two bytes (in the 3-byte block)
   224 000000FB 658A04              <1>   mov al, [gs:si]                                 ; read two bytes
   225 000000FE 658A6401            <1>   mov ah, [gs:si + 1]                             ; high byte in memory to low byte in ax, vise versa
   226                              <1> 
   227 00000102 80F900              <1>   cmp cl, 0
   228 00000105 7403                <1>   je nextcluster_fin
   229 00000107 C1E804              <1>   shr ax, 4
   230                              <1> 
   231                              <1> nextcluster_fin:
   232 0000010A 25FF0F              <1>   and ax, 0000111111111111b                       ; pick up the lower 12-bit since all cluster
   233                              <1>                                                   ; descriptor contains only 12 bit
   234 0000010D 5B                  <1>   pop bx
   235 0000010E 5E                  <1>   pop si
   236 0000010F C3                  <1>   ret
   237                              <1> 
   238                              <1> 
   239                              <1> ; -------------------------------------- Assistant Functions ------------------------------------
   240                              <1> ; 中断13，AH = 2 - 读取
   241                              <1> ; 读磁盘
   242                              <1> ;   AL=扇区数
   243                              <1> ;   CH,CL=磁盘号,扇区号
   244                              <1> ;   DH,DL=磁头号,驱动器号
   245                              <1> ;   ES:BX=数据缓冲区地址  
   246                              <1> ; Return Value
   247                              <1> ;   读成功:AH=0
   248                              <1> ;   AL=读取的扇区数
   249                              <1> ;   读失败:AH=出错代码
   250                              <1> 
   251                              <1> ; readsec 读逻辑扇区
   252                              <1> ; AX 起始扇区 (ranges from 0 to 2879)
   253                              <1> ; CX 待读个数
   254                              <1> ; ES:BX 数据缓冲区地址
   255                              <1> 
   256                              <1> ; NOTE: BX若跨越段则可能造成错误！！！
   257                              <1> readsec:
   258 00000110 53                  <1>   push bx
   259 00000111 50                  <1>   push ax
   260 00000112 52                  <1>   push dx
   261 00000113 51                  <1>   push cx                             ; since bx is used in following lines, we need to store its
   262                              <1>   
   263 00000114 53                  <1>   push bx                             ; value temporarily
   264 00000115 B312                <1>   mov bl, CFAT12_SecPerTrk
   265 00000117 F6F3                <1>   div bl                              ; AX % BL = AH, AX / BL = AL
   266 00000119 5B                  <1>   pop bx
   267 0000011A 88C6                <1>   mov dh, al                          ; 求磁头号
   268 0000011C 80E601              <1>   and dh, 0x01                        ; 若是偶数，则磁头号为0，否则为1
   269 0000011F D0E8                <1>   shr al, 1
   270 00000121 88C5                <1>   mov ch, al                          ; 柱面号 or 磁道号 
   271 00000123 88E1                <1>   mov cl, ah                          ; 起始扇区号
   272 00000125 80C101              <1>   add cl, 1                           ; obviously cl in [0, 17] and we need it to be [1, 18]
   273 00000128 B200                <1>   mov dl, CFAT12_DrvNum
   274 0000012A 58                  <1>   pop ax                              ; 将待读个数CX弹到AX中，用AX为计数器
   275                              <1> 
   276                              <1> 
   277                              <1> readsec_loop:
   278 0000012B 50                  <1>   push ax
   279 0000012C B001                <1>   mov al, 1                           ; 每次只读1个扇区
   280 0000012E B402                <1>   mov ah, 2                           ; 设定为读取磁盘模式
   281                              <1>   tryread:
   282 00000130 CD13                <1>     int 0x13
   283 00000132 72FC                <1>     jc tryread                        ; 若失败则重新读取
   284 00000134 58                  <1>   pop ax
   285 00000135 81C30002            <1>   add bx, 512                         ; 指针向后一个扇区
   286 00000139 E80A00              <1>   call readsec_secinc                 ; 扇区自增
   287 0000013C 83E801              <1>   sub ax, 1                           ; 计数器 -1
   288 0000013F 83F800              <1>   cmp ax, 0
   289 00000142 741B                <1>   je readsec_end
   290 00000144 EBE5                <1>   jmp readsec_loop
   291                              <1> 
   292                              <1> ; 子函数，使得逻辑扇区+1并计算对应的柱面-磁头-扇区表示
   293                              <1> readsec_secinc:
   294 00000146 80C101              <1>   add cl, 1
   295 00000149 80F913              <1>   cmp cl, 19
   296 0000014C 7510                <1>   jne readsec_secinc_end              ; 若扇区号尚不足19，自增后可直接退出
   297                              <1>                                       ; 扇区范围为 1-19 [重要!!!!!!!!!!!!!!!!!]
   298 0000014E B101                <1>     mov cl, 1                         ; 否则变化磁头号
   299 00000150 80FE00              <1>     cmp dh, 0                         ; 若磁头号为0, 则磁道号加1
   300 00000153 7504                <1>     jne readsec_secinc_cyninc         ; 若磁头号已经为1, 则磁道号清零并增加柱面号
   301 00000155 B601                <1>     mov dh, 1                         ; 若磁头号尚未0, 则磁道号+1并退出
   302 00000157 EB05                <1>     jmp readsec_secinc_end
   303                              <1>   readsec_secinc_cyninc:              ; 柱面号需+1
   304 00000159 B600                <1>     mov dh, 0
   305 0000015B 80C501              <1>     add ch, 1
   306                              <1>   readsec_secinc_end:
   307 0000015E C3                  <1>     ret
   308                              <1> 
   309                              <1> readsec_end:
   310 0000015F 5A                  <1>   pop dx
   311 00000160 58                  <1>   pop ax
   312 00000161 5B                  <1>   pop bx
   313 00000162 C3                  <1>   ret
   314                              <1> 
   315                              <1> ; -------------------------------------- Data Segment -------------------------------------------
   316 00000163 00                  <1> MaxItem       db 0x00                  
   317                              <1> ; used when searching for certain files
   318                              <1> ; ------------------------------------------------------------------------------------------------
   319                              <1> ; 一些基于FAT12头的常量定义
   320                              <1> ; ------------------------------------------------------------------------------------------------
   321                              <1> 
   322                              <1> CFAT12_DrvNum            equ   0
   323                              <1> CFAT12_BytesPerSec       equ   512
   324                              <1> CFAT12_SecPerFAT         equ   9                                            ; number of sectors in each FAT
   325                              <1> CFAT12_SecPerTrk         equ   18                                           ; number of sectors in each Track
   326                              <1> CFAT12_RootSectors       equ   CFAT12_RootEntCnt * CFAT12_RootItemLen / 512 ; number of sectors that contains root items
   327                              <1> CFAT12_SecNoOfRoot       equ   CFAT12_SecNoOfFAT1 + 2 * CFAT12_SecPerFAT    ; index of root directory table's starting location
   328                              <1> CFAT12_SecNoOfFAT1       equ   1                                            ; index of FAT1's starting section
   329                              <1> CFAT12_RootEntCnt        equ   224                                          ; maximal number of items in root directory
   330                              <1> CFAT12_SecNoClstZero     equ   CFAT12_SecNoOfRoot + CFAT12_RootSectors - 2  ; the sector index of cluster 0
   331                              <1>                                                                             ; since the data cluster starts from cluster 2
   332                              <1>                                                                             ; we need to decrease 2 here
   333                              <1> 
   334                              <1> CFAT12_RootItemLen       equ   32
   335                                  %include "print.asm"
   336                              <1> ; print函数在屏幕上显示制定内容
   337                              <1> ; - 以0x0a作为换行符
   338                              <1> ; - 以0x00作为终止符
   339                              <1> ; - 输入字符串的地址由 AX:BX 给出
   340                              <1> 
   341                              <1> [section .text]
   342                              <1> 
   343                              <1> ; --------------------------------------- print a string ----------------------------------------
   344                              <1> printstr:
   345 00000164 50                  <1>   push ax
   346 00000165 53                  <1>   push bx
   347 00000166 0FA8                <1>   push gs
   348 00000168 56                  <1>   push si
   349 00000169 89DE                <1>   mov si, bx
   350 0000016B 8EE8                <1>   mov gs, ax
   351                              <1> 
   352                              <1>   printstr_loop:
   353 0000016D 658A04              <1>     mov al, [gs:si]
   354 00000170 3C00                <1>     cmp al, 0
   355 00000172 7415                <1>     je printstr_end             ; 若AL = 0 则停止工作. 此处若改为JE entry则可无限向屏幕写入字符串
   356 00000174 3C0A                <1>     cmp al, 0x0a                ; 处理换行符
   357 00000176 7506                <1>     jne printstr_noendl
   358 00000178 E8F400              <1>     call printendl
   359 0000017B 46                  <1>     inc si
   360 0000017C EBEF                <1>     jmp printstr_loop
   361                              <1> 
   362                              <1>   printstr_noendl:
   363 0000017E B301                <1>     mov bl, 01                  ; 选择前景色。不过不切换显示模式的话貌似无用
   364 00000180 B40E                <1>     mov ah, 0x0e                ; 选择中断功能：显示字符并后移光标
   365 00000182 CD10                <1>     int 0x10                    ; 调用显示中断
   366 00000184 83C601              <1>     add si, 1
   367 00000187 EBE4                <1>     jmp printstr_loop
   368                              <1> 
   369                              <1>   printstr_end:
   370 00000189 5E                  <1>     pop si
   371 0000018A 0FA9                <1>     pop gs
   372 0000018C 5B                  <1>     pop bx
   373 0000018D 58                  <1>     pop ax
   374 0000018E C3                  <1>     ret
   375                              <1> 
   376                              <1> ; ----------------------------------------- print memory -----------------------------------------
   377                              <1> ; AX - base address
   378                              <1> ; BX - offset
   379                              <1> ; - in this function, we're going to print ... bytes of memory starting from AX:BX
   380                              <1> ; - 16 bytes per line
   381                              <1> printmemory:
   382 0000018F 0FA8                <1>   push gs
   383 00000191 56                  <1>   push si
   384 00000192 50                  <1>   push ax
   385 00000193 53                  <1>   push bx
   386                              <1> 
   387 00000194 E8D800              <1>   call printendl                 ; first we provide a endline
   388 00000197 8EE8                <1>   mov gs, ax                     ; set base address
   389 00000199 89DE                <1>   mov si, bx                     ; set offset
   390 0000019B B81000              <1>   mov ax, 0x10                   ; print 16 lines
   391                              <1>   printmemory_loop:
   392 0000019E E82E00              <1>     call printmemoryaddr         ; print the address
   393 000001A1 E8A200              <1>     call printspace
   394                              <1> 
   395                              <1>     ; inner loop: print one line
   396 000001A4 50                  <1>     push ax
   397 000001A5 B81000              <1>       mov ax, 16
   398                              <1>       printmemory_lineloop:
   399 000001A8 50                  <1>         push ax
   400 000001A9 658A04              <1>         mov al, [gs:si]
   401 000001AC E84E00              <1>         call printbyte
   402 000001AF 58                  <1>         pop ax
   403 000001B0 E89300              <1>         call printspace
   404 000001B3 83C601              <1>         add si, 1
   405 000001B6 48                  <1>         dec ax
   406 000001B7 83F800              <1>         cmp ax, 0
   407 000001BA 75EC                <1>         jne printmemory_lineloop
   408 000001BC 58                  <1>     pop ax
   409                              <1> 
   410 000001BD E8AF00              <1>     call printendl
   411                              <1> 
   412 000001C0 48                  <1>     dec ax
   413 000001C1 83F800              <1>     cmp ax, 0
   414 000001C4 75D8                <1>     jne printmemory_loop
   415                              <1> 
   416                              <1>   ; finally, use an endl to split between other messages
   417 000001C6 E8A600              <1>   call printendl
   418 000001C9 5B                  <1>   pop bx
   419 000001CA 58                  <1>   pop ax
   420 000001CB 5E                  <1>   pop si
   421 000001CC 0FA9                <1>   pop gs
   422 000001CE C3                  <1>   ret
   423                              <1> 
   424                              <1> printmemoryaddr:
   425 000001CF 50                  <1>   push ax
   426 000001D0 8CE8                <1>   mov ax, gs
   427 000001D2 E81B00              <1>   call printword
   428 000001D5 B03A                <1>   mov al, ':'
   429 000001D7 E88A00              <1>   call printsymbol
   430 000001DA 89F0                <1>   mov ax, si
   431 000001DC E81100              <1>   call printword
   432 000001DF 58                  <1>   pop ax
   433 000001E0 C3                  <1>   ret
   434                              <1> 
   435                              <1> 
   436                              <1> ; ----------------------------------------- print number -----------------------------------------
   437                              <1> ; AX/EAX - the word we need to print, e.g. 0x1234
   438                              <1> printdword:
   439 000001E1 6650                <1>   push eax
   440 000001E3 66C1E810            <1>   shr eax, 16
   441 000001E7 E80600              <1>   call printword
   442 000001EA 6658                <1>   pop eax
   443 000001EC E80100              <1>   call printword
   444 000001EF C3                  <1>   ret
   445                              <1> 
   446                              <1> printword:
   447 000001F0 50                  <1>   push ax
   448 000001F1 50                  <1>   push ax                          ; preserve ax firstly
   449 000001F2 88E0                <1>   mov al, ah                       ; print the high 8 bits
   450 000001F4 E80600              <1>   call printbyte
   451 000001F7 58                  <1>   pop ax                           ; restore ax and print the lower 8 bits
   452 000001F8 E80200              <1>   call printbyte
   453 000001FB 58                  <1>   pop ax
   454 000001FC C3                  <1>   ret
   455                              <1> 
   456                              <1> ; the byte should be stored in AL
   457                              <1> printbyte:
   458 000001FD 53                  <1>   push bx
   459 000001FE 50                  <1>   push ax
   460 000001FF B300                <1>   mov bl, 0
   461 00000201 B40E                <1>   mov ah, 0x0E
   462 00000203 88C7                <1>   mov bh, al                       ; backup al with bh
   463 00000205 C0E804              <1>   shr al, 4                        ; high 4-bits first
   464 00000208 240F                <1>   and al, 00001111b
   465 0000020A E80E00              <1>   call printword_al2chr
   466 0000020D CD10                <1>   int 0x10
   467 0000020F 88F8                <1>   mov al, bh                       ; restore al
   468 00000211 240F                <1>   and al, 00001111b
   469 00000213 E80500              <1>   call printword_al2chr
   470 00000216 CD10                <1>   int 0x10
   471 00000218 58                  <1>   pop ax
   472 00000219 5B                  <1>   pop bx
   473 0000021A C3                  <1>   ret
   474                              <1> 
   475                              <1> 
   476                              <1> printword_al2chr:
   477 0000021B 0430                <1>   add al, 0x30
   478 0000021D 3C39                <1>   cmp al, 57
   479 0000021F 7603                <1>   jna printword_al2chr_end
   480 00000221 0407                <1>     add al, 7
   481 00000223 C3                  <1>     ret
   482                              <1>   printword_al2chr_end:
   483 00000224 C3                  <1>     ret
   484                              <1> 
   485                              <1> ; ----------------------------------------- reset screen -----------------------------------------
   486                              <1> screen_reset:
   487 00000225 50                  <1>   push ax                        ; store the registers
   488 00000226 53                  <1>   push bx
   489 00000227 51                  <1>   push cx
   490 00000228 52                  <1>   push dx
   491                              <1>   ; step 1. reset color
   492 00000229 B000                <1>   mov al, 0
   493 0000022B B74F                <1>   mov bh, 0x4F
   494 0000022D B90000              <1>   mov cx, 0
   495 00000230 B250                <1>   mov dl, 80                  ; column number of the right below corner
   496 00000232 B619                <1>   mov dh, 25                  ; row number of ....
   497 00000234 B406                <1>   mov ah, 6                   ; function set to `roll up`
   498 00000236 CD10                <1>   int 0x10                    ; call the interruption
   499                              <1>   ; step 2. reset position
   500 00000238 B402                <1>   mov ah, 2                   ; reset cursor
   501 0000023A B700                <1>   mov bh, 0                   ; page number = 0
   502 0000023C BA0000              <1>   mov dx, 0                   ; position reset as dh = 0, dl = 0
   503 0000023F CD10                <1>   int 0x10
   504 00000241 5A                  <1>   pop dx
   505 00000242 59                  <1>   pop cx
   506 00000243 5B                  <1>   pop bx
   507 00000244 58                  <1>   pop ax
   508 00000245 C3                  <1>   ret
   509                              <1> 
   510                              <1> ; ------------------------------------------------------------------------------------------------
   511                              <1> printspace:
   512 00000246 53                  <1>   push bx
   513 00000247 50                  <1>   push ax
   514 00000248 B300                <1>   mov bl, 0
   515 0000024A B40E                <1>   mov ah, 0x0E
   516 0000024C B020                <1>   mov al, ' '
   517 0000024E CD10                <1>   int 0x10
   518 00000250 58                  <1>   pop ax
   519 00000251 5B                  <1>   pop bx
   520 00000252 C3                  <1>   ret
   521                              <1> 
   522                              <1> printhexhead:
   523 00000253 53                  <1>   push bx
   524 00000254 50                  <1>   push ax
   525 00000255 B300                <1>   mov bl, 0
   526 00000257 B40E                <1>   mov ah, 0x0E
   527 00000259 B030                <1>   mov al, '0'
   528 0000025B CD10                <1>   int 0x10
   529 0000025D B078                <1>   mov al, 'x'
   530 0000025F CD10                <1>   int 0x10
   531 00000261 58                  <1>   pop ax
   532 00000262 5B                  <1>   pop bx
   533 00000263 C3                  <1>   ret
   534                              <1> 
   535                              <1> printsymbol:
   536 00000264 53                  <1>   push bx
   537 00000265 50                  <1>   push ax
   538 00000266 B300                <1>   mov bl, 0
   539 00000268 B40E                <1>   mov ah, 0x0E
   540 0000026A CD10                <1>   int 0x10
   541 0000026C 58                  <1>   pop ax
   542 0000026D 5B                  <1>   pop bx
   543 0000026E C3                  <1>   ret
   544                              <1> 
   545                              <1> ; endl 的机制：
   546                              <1> ; - 读取当前光标位置
   547                              <1> ; - 重设光标位置，令行数+1，列数清零
   548                              <1> printendl:
   549 0000026F 53                  <1>   push bx
   550 00000270 50                  <1>   push ax
   551                              <1>   ; 调取当前光标
   552 00000271 B700                <1>   mov bh, 0
   553 00000273 B403                <1>   mov ah, 3
   554 00000275 CD10                <1>   int 0x10
   555                              <1>   ; 重写当前光标
   556 00000277 FEC6                <1>   inc dh
   557 00000279 B200                <1>   mov dl, 0
   558 0000027B B402                <1>   mov ah, 2
   559 0000027D CD10                <1>   int 0x10
   560 0000027F 58                  <1>   pop ax
   561 00000280 5B                  <1>   pop bx
   562 00000281 C3                  <1>   ret
   563                                  %include "gdt.asm"
   564                              <1> ; all descriptions of gdt are defined in this file
   565                              <1> 
   566                              <1> %include "gdtmicro.asm"
   567                              <2> %macro descriptor 3
   568                              <2>   dw (%2) & 0ffffh                   ; 界限值0-15位
   569                              <2>   dw (%1) & 0ffffh                   ; 基地址0-15位
   570                              <2>   db ((%1) >> 16) & 0ffh             ; 基地址16-23位
   571                              <2>   dw (((%2) >> 8) & 0f00h) | (%3)    ; 界限值16-19位，和段属性
   572                              <2>   db ((%1) >> 24) & 0ffh             ; 基地址24-31位
   573                              <2> %endmacro
   574                              <2> 
   575                              <2> SA_BYTES        equ 0 << 15          ; 段粒度：字节, 段限长的20位即位实际限长
   576                              <2> SA_PAGES        equ 1 << 15          ; 段粒度：页，段现场的20位乘以2^12凑足32位，最大限长为4GB
   577                              <2> 
   578                              <2> SA_16BIT        equ 0 << 14          ; 16位段
   579                              <2> SA_32BIT        equ 1 << 14          ; 32位段
   580                              <2> 
   581                              <2> ; 13 位始终为 0
   582                              <2> 
   583                              <2> SA_ABSENT       equ 0 << 7           ; 不存在
   584                              <2> SA_PRESENT      equ 1 << 7           ; 存在
   585                              <2> 
   586                              <2> SA_DPL_0        equ 0 << 5           ; 段特权级0-3, 表示访问该段时CPU所需处于的最低特权级
   587                              <2> SA_DPL_1        equ 1 << 5
   588                              <2> SA_DPL_2        equ 2 << 5
   589                              <2> SA_DPL_3        equ 3 << 5
   590                              <2> 
   591                              <2> SA_SYSTEM       equ 0 << 4           ; 系统段
   592                              <2> SA_STORAGE      equ 1 << 4           ; 存储段
   593                              <2> 
   594                              <2> SA_DATA         equ 0 << 3           ; 数据段
   595                              <2> SA_CODE         equ 1 << 3           ; 代码段
   596                              <2> 
   597                              <2> SA_EXTHIGH      equ 0 << 2           ; 向高位扩展（数据段）
   598                              <2> SA_EXTLOW       equ 1 << 2           ; 向低位扩展（数据段）
   599                              <2> SA_STACK        equ 0 << 2           ; 普通代码段（代码段）
   600                              <2> SA_CONFORM      equ 1 << 2           ; 一致代码段（代码段）
   601                              <2> 
   602                              <2> SA_READONLY     equ 0 << 1           ; 只读
   603                              <2> SA_WRITABLE     equ 1 << 1           ; 可写
   604                              <2> 
   605                              <2> SA_UNACCESSED   equ 0 << 0           ; 未访问
   606                              <2> SA_ACCESSED     equ 1 << 0           ; 已访问
   607                              <1> 
   608                              <1> [section .data]
   609                              <1> 
   610                              <1> gdt:
   611                              <1>   descriptor 0, 0, 0
   612 00000000 0000                <2>  dw (%2) & 0ffffh
   613 00000002 0000                <2>  dw (%1) & 0ffffh
   614 00000004 00                  <2>  db ((%1) >> 16) & 0ffh
   615 00000005 0000                <2>  dw (((%2) >> 8) & 0f00h) | (%3)
   616 00000007 00                  <2>  db ((%1) >> 24) & 0ffh
   617                              <1> 
   618                              <1> gdtseg_stackseg:
   619                              <1>   descriptor Stack32BaseAddr,              Kernel32SegBaseAddr - Stack32BaseAddr,              SA_DATA|SA_WRITABLE|SA_STORAGE|SA_32BIT|SA_PRESENT
   620 00000008 0000                <2>  dw (%2) & 0ffffh
   621 0000000A 0000                <2>  dw (%1) & 0ffffh
   622 0000000C 01                  <2>  db ((%1) >> 16) & 0ffh
   623 0000000D 9241                <2>  dw (((%2) >> 8) & 0f00h) | (%3)
   624 0000000F 00                  <2>  db ((%1) >> 24) & 0ffh
   625                              <1> 
   626                              <1> gdtseg_loader32seg:
   627                              <1>   descriptor LoaderBaseAddr << 4,              0xfffff,              SA_CODE|SA_WRITABLE|SA_STORAGE|SA_32BIT|SA_PRESENT
   628 00000010 FFFF                <2>  dw (%2) & 0ffffh
   629 00000012 001C                <2>  dw (%1) & 0ffffh
   630 00000014 08                  <2>  db ((%1) >> 16) & 0ffh
   631 00000015 9A4F                <2>  dw (((%2) >> 8) & 0f00h) | (%3)
   632 00000017 00                  <2>  db ((%1) >> 24) & 0ffh
   633                              <1> 
   634                              <1> gdtseg_kernelseg:
   635                              <1>   descriptor Kernel32SegBaseAddr,              0xfffff,              SA_CODE|SA_WRITABLE|SA_STORAGE|SA_32BIT|SA_PRESENT
   636 00000018 FFFF                <2>  dw (%2) & 0ffffh
   637 0000001A 0000                <2>  dw (%1) & 0ffffh
   638 0000001C 02                  <2>  db ((%1) >> 16) & 0ffh
   639 0000001D 9A4F                <2>  dw (((%2) >> 8) & 0f00h) | (%3)
   640 0000001F 00                  <2>  db ((%1) >> 24) & 0ffh
   641                              <1> 
   642                              <1> gdtseg_videoseg:
   643                              <1>   descriptor 0x000B8000,              0xffff,              SA_DATA|SA_WRITABLE|SA_STORAGE|SA_PRESENT
   644 00000020 FFFF                <2>  dw (%2) & 0ffffh
   645 00000022 0080                <2>  dw (%1) & 0ffffh
   646 00000024 0B                  <2>  db ((%1) >> 16) & 0ffh
   647 00000025 9200                <2>  dw (((%2) >> 8) & 0f00h) | (%3)
   648 00000027 00                  <2>  db ((%1) >> 24) & 0ffh
   649                              <1> 
   650                              <1> gdtlen                  equ $ - gdt
   651                              <1> 
   652                              <1> gdtselector_stackseg    equ gdtseg_stackseg - gdt
   653                              <1> gdtselector_loader32seg equ gdtseg_loader32seg - gdt
   654                              <1> gdtselector_kernelseg   equ gdtseg_kernelseg - gdt
   655                              <1> gdtselector_video       equ gdtseg_videoseg - gdt
   656                              <1> 
   657                              <1> gdtr:
   658 00000028 2700                <1>   dw gdtlen - 1
   659 0000002A [001C0800]          <1>   dd (LoaderBaseAddr << 4) + gdt
   660                                  %include "loaderin32.asm"
   661                              <1> [section .text]
   662                              <1> [bits 32]
   663                              <1> 
   664                              <1> entry32:
   665                              <1>   ; 堆栈初始化
   666                              <1>   ; 务须注意，所有可能用到的段寄存器均须初始化为某个合法段
   667 00000282 66B80800            <1>   mov ax, gdtselector_stackseg
   668 00000286 8ED0                <1>   mov ss, ax
   669 00000288 66B81000            <1>   mov ax, gdtselector_loader32seg
   670 0000028C 8ED8                <1>   mov ds, ax
   671 0000028E 8EC0                <1>   mov es, ax
   672 00000290 8EE8                <1>   mov gs, ax
   673 00000292 BCF0FF0000          <1>   mov esp, Kernel32SegBaseAddr - Stack32BaseAddr - 16
   674 00000297 89E5                <1>   mov ebp, esp
   675 00000299 BA[9B000000]        <1>   mov edx, ProtectedReadyStr
   676 0000029E E802000000          <1>   call print
   677 000002A3 EBFE                <1>   jmp $
   678                              <1> 
   679                              <1> %include "print32.asm"
   680                              <2> ; 这是一个在32-bit 保护模式下运行的显示库
   681                              <2> 
   682                              <2> [bits 32]
   683                              <2> ; EDX 给定数据偏移
   684                              <2> 
   685                              <2> print:                                 ; 这是一个用来显示字符串的函数
   686 000002A5 50                  <2>   push eax
   687 000002A6 0FA8                <2>   push gs
   688 000002A8 1E                  <2>   push ds
   689 000002A9 66B82000            <2>   mov ax, gdtselector_video
   690 000002AD 8EE8                <2>   mov gs, ax                           ; 指定显存段索引
   691 000002AF 66B81000            <2>   mov ax, gdtselector_loader32seg
   692 000002B3 8ED8                <2>   mov ds, ax                           ; 指定数据段索引
   693 000002B5 B800000000          <2>   mov eax, 0
   694 000002BA 89C7                <2>   mov edi, eax                         ; DI初始化为显存偏移，其中高位表示列偏移，低位表示行偏移
   695 000002BC 89D6                <2>   mov esi, edx                         ; SI初始化为数据偏移位置
   696                              <2> 
   697                              <2> printloop:
   698 000002BE 3E8A06              <2>   mov al, [ds:esi]                     ; 获取一个字符
   699 000002C1 3C00                <2>   cmp al, 0x00                         ; 若是0x00，则停止写入
   700 000002C3 740B                <2>   je printend                          ; 跳到printend处，返回
   701 000002C5 658807              <2>   mov [gs:edi], al                     ; 写入显存
   702 000002C8 83C601              <2>   add esi, 1                           ; 指针自增
   703 000002CB 83C702              <2>   add edi, 2                           ; 显存指针+2 | todo 显存指针可能溢出
   704 000002CE EBEE                <2>   jmp printloop                        ; 反复写入直到字符串结束
   705                              <2> 
   706                              <2> printend:
   707 000002D0 1F                  <2>   pop ds
   708 000002D1 0FA9                <2>   pop gs
   709 000002D3 58                  <2>   pop eax
   710 000002D4 C3                  <2>   ret
   711                                  
   712                                  ; ---------------------------------------- 数据段 ------------------------------------------------
   713                                  [section .data]
   714 0000002E 426F6F74204C6F6164-     LoaderReadyStr     db  "Boot Loader online, trying to locate the kernel ... ", 0x00
   715 00000037 6572206F6E6C696E65-
   716 00000040 2C20747279696E6720-
   717 00000049 746F206C6F63617465-
   718 00000052 20746865206B65726E-
   719 0000005B 656C202E2E2E2000   
   720 00000063 444F4E452E0A00          KernelReadyStr     db  "DONE.", 0x0a, 0x00
   721 0000006A 4A756D70696E672069-     ProtectedModeIn    db  "Jumping into protected mode ... ", 0x00
   722 00000073 6E746F2070726F7465-
   723 0000007C 63746564206D6F6465-
   724 00000085 202E2E2E2000       
   725 0000008B 4641494C45440A00        FailLoadingStr     db  "FAILED", 0x0a, 0x00
   726 00000093 4B45524E454C2020        KernelName         db  "KERNEL  "
   727 0000009B 50726F746563746564-     ProtectedReadyStr  db  "Protected Mode is ready, now analyzing kernel binary ... ", 0x00
   728 000000A4 204D6F646520697320-
   729 000000AD 72656164792C206E6F-
   730 000000B6 7720616E616C797A69-
   731 000000BF 6E67206B65726E656C-
   732 000000C8 2062696E617279202E-
   733 000000D1 2E2E2000           
