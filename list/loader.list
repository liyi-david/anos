     1                                  ; ----------------------------------------- 常量定义 ---------------------------------------------
     2                                  %include "memorymap.asm"
     3                              <1> ; ------------------------------------------------------------------------------------------------
     4                              <1> ; memorymap.asm
     5                              <1> ; - all base addreses and offsets are defined in this section
     6                              <1> ; ------------------------------------------------------------------------------------------------
     7                              <1> 
     8                              <1> ; ----------------------------------------- 内存区划 ---------------------------------------------
     9                              <1> ; 0x0000 - 0x7c00 系统预留
    10                              <1> ; 0x7c00 - 0x7e00 引导扇区
    11                              <1> ; 0x7e00 - 0x8000 堆栈(512 Byte)
    12                              <1> ; 0x8000 - 0x9200 FAT(512 Byte * 9)
    13                              <1> ; 0x9200 - 0x9A00 Loader.bin
    14                              <1> ; 0x9A00 -        Kernel.bin
    15                              <1> 
    16                              <1> ; todo need rewrite !!!!!!!!!!
    17                              <1> 
    18                              <1> SectorSize            equ 0x0200
    19                              <1> 
    20                              <1> BootLoaderOffsetAddr  equ 0x7c00
    21                              <1> 
    22                              <1> StackBaseAddr         equ 0x0000
    23                              <1> StackOffsetAddr       equ 0x7e00                                      ; 0x7c00 + SectorSize
    24                              <1> FATBaseAddr           equ 0x8000                                      ; 0x80000
    25                              <1> FATOffsetAddr         equ 0x0000
    26                              <1> LoaderBaseAddr        equ 0x81c0                                      ; FATBaseAddr + SectorSize * 14 / 0x000F
    27                              <1> LoaderOffsetAddr      equ 0x0000
    28                              <1> KernelBaseAddr        equ LoaderBaseAddr + SectorSize * 4 / 0x000F     ; 9c00 - ...
    29                              <1> KernelOffsetAddr      equ 0x0000
    30                                  ; ------------------------------------------ 程序主体 --------------------------------------------
    31                                  ; 
    32                                  org   LoaderOffsetAddr
    33                                  ;--------------------------------------- FAT12 格式描述 ------------------------------------------
    34                                  ; FAT12 引导扇区格式参见 http://blog.sina.com.cn/s/blog_3edcf6b80100cr08.html
    35                                  
    36 00000000 E8AD01                  call screen_reset                                                     ; 重设屏幕
    37                                  
    38 00000003 B8C081                  mov ax, LoaderBaseAddr
    39 00000006 BB[0202]                mov bx, LoaderReadyStr
    40 00000009 E81F01                  call printstr
    41                                  
    42                                  ; 指定输入文件地址
    43 0000000C B8[3E02]                mov ax, KernelName
    44 0000000F BB4882                  mov bx, KernelBaseAddr
    45 00000012 B90000                  mov cx, KernelOffsetAddr
    46 00000015 E80F00                  call loadfile
    47                                  
    48                                  ; 内核载入完成
    49 00000018 8CC8                    mov ax, cs
    50 0000001A BB[3702]                mov bx, KernelReadyStr
    51 0000001D E80B01                  call printstr
    52                                  
    53 00000020 EBFE                    jmp $
    54 00000022 EA00004882              jmp KernelBaseAddr:KernelOffsetAddr
    55                                  
    56                                  ; call dispstr
    57                                  ; todo deal with data segment
    58                                  ; todo make display.asm ready for both two binaries
    59                                  
    60                                  
    61                                  ; --------------------------------------- import libraries ---------------------------------------
    62                                  %include "floppy.asm"
    63                              <1> ; debug
    64                              <1> ;printdebugsym:
    65                              <1>   ;push bx
    66                              <1>   ;push ax
    67                              <1>   ;mov bl, 0
    68                              <1>   ;mov ah, 0x0E
    69                              <1>   ;mov al, bh
    70                              <1>   ;add al, 0x30
    71                              <1>   ;int 0x10
    72                              <1>   ;mov al, bl
    73                              <1>   ;add al, 0x30
    74                              <1>   ;int 0x10
    75                              <1>   ;mov al, '/'
    76                              <1>   ;int 0x10
    77                              <1>   ;pop ax
    78                              <1>   ;pop bx
    79                              <1>   ;ret
    80                              <1> 
    81                              <1> ; 这个文件是用来存放软盘读写的 API
    82                              <1> ; http://blog.csdn.net/littlehedgehog/article/details/2147361
    83                              <1> 
    84                              <1> ; 输入参数:
    85                              <1> ; AX - 待载入文件的文件名（前8位）地址
    86                              <1> ; BX - 将要载入到的位置段
    87                              <1> ; CX - 将要载入到的位置偏移
    88                              <1> 
    89                              <1> ; 返回值 - AH = 0 (正确载入)
    90                              <1> ; AH = 1 (出现错误)
    91                              <1> loadfile:
    92                              <1>   ; 载入根目录文件表
    93 00000027 51                  <1>   push cx
    94 00000028 53                  <1>   push bx
    95 00000029 50                  <1>   push ax
    96 0000002A B80080              <1>   mov ax, FATBaseAddr                             ; 设置数据缓冲基地址
    97 0000002D 8EC0                <1>   mov es, ax
    98 0000002F BB0000              <1>   mov bx, FATOffsetAddr                           ; 设置数据缓冲偏移
    99 00000032 B81300              <1>   mov ax, CFAT12_SecNoOfRoot                      ; 0 - boot sector, 1 - 9/10 - 18 : FAT1/2
   100 00000035 B90E00              <1>   mov cx, CFAT12_RootSectors                      ; number of sectors
   101 00000038 E89C00              <1>   call readsec                                    ; obtain the root directory items
   102                              <1>   ; 根目录载入完毕
   103                              <1>   ; 接下来查找根目录中的全部224项，检查是否存在指定名称的字符串
   104 0000003B BA0000              <1>   mov dx, FATOffsetAddr
   105 0000003E 83EA20              <1>   sub dx, CFAT12_RootItemLen
   106 00000041 89D6                <1>   mov si, dx
   107 00000043 C606[2A01]E0        <1>   mov byte [MaxItem], CFAT12_RootEntCnt           ; maximal iteration limit
   108                              <1> 
   109                              <1> ; 查找Loader
   110                              <1> ; 过程中，es:si始终指向当前根目录项的首位值
   111                              <1> ; 首先我们将文件名地址出到di处
   112 00000048 5F                  <1>   pop di 
   113                              <1> 
   114                              <1> search_file:
   115 00000049 83C620              <1>   add si, CFAT12_RootItemLen                      ; jump to next item
   116 0000004C 802E[2A01]01        <1>   sub byte [MaxItem], 1                           ; decrease the limit counter
   117 00000051 803E[2A01]00        <1>   cmp byte [MaxItem], 0
   118 00000056 7450                <1>   je loader_loader_fail                           ; we have meet the limit
   119 00000058 668B05              <1>   mov eax, [di]
   120 0000005B 26663904            <1>   cmp dword [es:si], eax                          ; compare first 4 chars
   121 0000005F 75E8                <1>   jne search_file                                 ; 如果不相同，则说明前4位不符
   122 00000061 668B4504            <1>   mov eax, [di+4]
   123 00000065 2666394404          <1>   cmp dword [es:si+4], eax
   124 0000006A 75DD                <1>   jne search_file
   125                              <1> 
   126                              <1> ; 若找到文件，则马上从项目中取出相应的首簇号
   127                              <1> save_clusterNo:
   128 0000006C 268B441A            <1>   mov ax, [es:si + 26]                            ; no. cluster is located with an offset 26
   129 00000070 50                  <1>   push ax                                         ; put the cluster no. in the stack in case it
   130                              <1>                                                   ; probably be rewritten by readsec
   131                              <1>   ; mov eax, [ds:si + 28]                         ; filelength, currently not used
   132                              <1> 
   133                              <1> 
   134                              <1> load_FileAllocationTable:                         ; match found in DS:DX
   135 00000071 BB0000              <1>   mov bx, FATOffsetAddr
   136 00000074 B80100              <1>   mov ax, CFAT12_SecNoOfFAT1                      ; we're going to load the first FAT
   137 00000077 B90900              <1>   mov cx, CFAT12_SecPerFAT
   138 0000007A E85A00              <1>   call readsec
   139                              <1> 
   140                              <1> load_filebody:                                    ; we need to locate the kernel through FAT
   141 0000007D 8CC0                <1>   mov ax, es
   142 0000007F 8EE8                <1>   mov gs, ax                                      ; put the base address of FAT to gs
   143 00000081 58                  <1>   pop ax                                          ; 恢复簇号
   144 00000082 5B                  <1>   pop bx                                          ; initialize base address of loader.bin (line 7)
   145 00000083 8EC3                <1>   mov es, bx
   146 00000085 5B                  <1>   pop bx                                          ; initialize offset address of loader.bin
   147                              <1>   load_loader_loop:
   148                              <1>     ; we should check the cluster number FIRSTLY
   149 00000086 3DF80F              <1>     cmp ax, 0x0ff8                                ; if 0x0ff0 <= successor <= 0x0ff7, the cluster is
   150                              <1>                                                   ; broken and should not be used
   151 00000089 731A                <1>     jnb loader_loader_fin
   152 0000008B 3DF00F              <1>     cmp ax, 0x0ff0                                ; successor < 0x0ff0, that's good sectors
   153 0000008E 7318                <1>     jnb loader_loader_fail                           ; continue reading
   154                              <1>     ; obtain the current cluster
   155 00000090 83C01F              <1>     add ax, CFAT12_SecNoClstZero                  ; cluster no. -> sector no.
   156 00000093 B90100              <1>       mov cx, 1                                   ; one cluster, one time (very important)
   157 00000096 E83E00              <1>       call readsec                                ; read one sector as a cluster
   158 00000099 81C30002            <1>       add bx, CFAT12_BytesPerSec                  ; move the address pointer
   159 0000009D 83E81F              <1>     sub ax, CFAT12_SecNoClstZero                  ; sector no. -> cluster no. before continuing
   160 000000A0 E80A00              <1>     call nextcluster                              ; find the index of the successing cluster
   161 000000A3 EBE1                <1>     jmp load_loader_loop
   162                              <1> 
   163                              <1>   loader_loader_fin:
   164                              <1>     ; otherwise we have finished kernel loading
   165 000000A5 B400                <1>     mov ah, 0
   166 000000A7 C3                  <1>     ret
   167                              <1> 
   168                              <1>   loader_loader_fail:        ; NO Kernels Found !!!!!!
   169 000000A8 B401                <1>     mov ah, 1                ; 设置返回值
   170 000000AA 5B                  <1>     pop bx                   ; [重要] 在任意一个返回过程中都要正确清理堆栈
   171 000000AB 59                  <1>     pop cx
   172 000000AC C3                  <1>     ret
   173                              <1>     
   174                              <1> ; suppose AX stores the index of current cluster
   175                              <1> ; *nextcluster* generates the successor cluster index, stored in AX
   176                              <1> nextcluster:
   177 000000AD 56                  <1>   push si                                         ; put two registers in stack
   178 000000AE 53                  <1>   push bx
   179 000000AF 88C1                <1>   mov cl, al
   180 000000B1 80E101              <1>   and cl, 1                                       ; CL = AX % 2 = 0 / 1
   181 000000B4 D1E8                <1>   shr ax, 1                                       ; AX /= 2
   182 000000B6 89C3                <1>   mov bx, ax
   183 000000B8 D1E0                <1>   shl ax, 1                                       ; AX = 3 * AX
   184 000000BA 01D8                <1>   add ax, bx
   185 000000BC 89C6                <1>   mov si, ax                                      ; SI set to the offset of current 3-byte
   186 000000BE B500                <1>   mov ch, 0                                       ; let CX = CL
   187 000000C0 01CE                <1>   add si, cx                                      ; CX == 0 - pick up the first two bytes, otherwise
   188                              <1>                                                   ; the last two bytes (in the 3-byte block)
   189 000000C2 658A04              <1>   mov al, [gs:si]                                 ; read two bytes
   190 000000C5 658A6401            <1>   mov ah, [gs:si + 1]                             ; high byte in memory to low byte in ax, vise versa
   191                              <1> 
   192 000000C9 80F900              <1>   cmp cl, 0
   193 000000CC 7403                <1>   je nextcluster_fin
   194 000000CE C1E804              <1>   shr ax, 4
   195                              <1> 
   196                              <1> nextcluster_fin:
   197 000000D1 25FF0F              <1>   and ax, 0000111111111111b                       ; pick up the lower 12-bit since all cluster
   198                              <1>                                                   ; descriptor contains only 12 bit
   199 000000D4 5B                  <1>   pop bx
   200 000000D5 5E                  <1>   pop si
   201 000000D6 C3                  <1>   ret
   202                              <1> 
   203                              <1> 
   204                              <1> ; -------------------------------------- Assistant Functions ------------------------------------
   205                              <1> ; 中断13，AH = 2 - 读取
   206                              <1> ; 读磁盘
   207                              <1> ;   AL=扇区数
   208                              <1> ;   CH,CL=磁盘号,扇区号
   209                              <1> ;   DH,DL=磁头号,驱动器号
   210                              <1> ;   ES:BX=数据缓冲区地址  
   211                              <1> ; Return Value
   212                              <1> ;   读成功:AH=0
   213                              <1> ;   AL=读取的扇区数
   214                              <1> ;   读失败:AH=出错代码
   215                              <1> 
   216                              <1> ; readsec 读逻辑扇区
   217                              <1> ; AX 起始扇区 (ranges from 0 to 2879)
   218                              <1> ; CX 待读个数
   219                              <1> ; ES:BX 数据缓冲区地址
   220                              <1> 
   221                              <1> ; NOTE: BX若跨越段则可能造成错误！！！
   222                              <1> readsec:
   223 000000D7 53                  <1>   push bx
   224 000000D8 50                  <1>   push ax
   225 000000D9 52                  <1>   push dx
   226 000000DA 51                  <1>   push cx                             ; since bx is used in following lines, we need to store its
   227                              <1>   
   228 000000DB 53                  <1>   push bx                             ; value temporarily
   229 000000DC B312                <1>   mov bl, CFAT12_SecPerTrk
   230 000000DE F6F3                <1>   div bl                              ; AX % BL = AH, AX / BL = AL
   231 000000E0 5B                  <1>   pop bx
   232 000000E1 88C6                <1>   mov dh, al                          ; 求磁头号
   233 000000E3 80E601              <1>   and dh, 0x01                        ; 若是偶数，则磁头号为0，否则为1
   234 000000E6 D0E8                <1>   shr al, 1
   235 000000E8 88C5                <1>   mov ch, al                          ; 柱面号 or 磁道号 
   236 000000EA 88E1                <1>   mov cl, ah                          ; 起始扇区号
   237 000000EC 80C101              <1>   add cl, 1                           ; obviously cl in [0, 17] and we need it to be [1, 18]
   238 000000EF B200                <1>   mov dl, CFAT12_DrvNum
   239 000000F1 58                  <1>   pop ax                              ; 将待读个数CX弹到AX中，用AX为计数器
   240                              <1> 
   241                              <1> 
   242                              <1> readsec_loop:
   243 000000F2 50                  <1>   push ax
   244 000000F3 B001                <1>   mov al, 1                           ; 每次只读1个扇区
   245 000000F5 B402                <1>   mov ah, 2                           ; 设定为读取磁盘模式
   246                              <1>   tryread:
   247 000000F7 CD13                <1>     int 0x13
   248 000000F9 72FC                <1>     jc tryread                        ; 若失败则重新读取
   249 000000FB 58                  <1>   pop ax
   250 000000FC 81C30002            <1>   add bx, 512                         ; 指针向后一个扇区
   251 00000100 E80A00              <1>   call readsec_secinc                 ; 扇区自增
   252 00000103 83E801              <1>   sub ax, 1                           ; 计数器 -1
   253 00000106 83F800              <1>   cmp ax, 0
   254 00000109 741B                <1>   je readsec_end
   255 0000010B EBE5                <1>   jmp readsec_loop
   256                              <1> 
   257                              <1> ; 子函数，使得逻辑扇区+1并计算对应的柱面-磁头-扇区表示
   258                              <1> readsec_secinc:
   259 0000010D 80C101              <1>   add cl, 1
   260 00000110 80F913              <1>   cmp cl, 19
   261 00000113 7510                <1>   jne readsec_secinc_end              ; 若扇区号尚不足19，自增后可直接退出
   262                              <1>                                       ; 扇区范围为 1-19 [重要!!!!!!!!!!!!!!!!!]
   263 00000115 B101                <1>     mov cl, 1                         ; 否则变化磁头号
   264 00000117 80FE00              <1>     cmp dh, 0                         ; 若磁头号为0, 则磁道号加1
   265 0000011A 7504                <1>     jne readsec_secinc_cyninc         ; 若磁头号已经为1, 则磁道号清零并增加柱面号
   266 0000011C B601                <1>     mov dh, 1                         ; 若磁头号尚未0, 则磁道号+1并退出
   267 0000011E EB05                <1>     jmp readsec_secinc_end
   268                              <1>   readsec_secinc_cyninc:              ; 柱面号需+1
   269 00000120 B600                <1>     mov dh, 0
   270 00000122 80C501              <1>     add ch, 1
   271                              <1>   readsec_secinc_end:
   272 00000125 C3                  <1>     ret
   273                              <1> 
   274                              <1> readsec_end:
   275 00000126 5A                  <1>   pop dx
   276 00000127 58                  <1>   pop ax
   277 00000128 5B                  <1>   pop bx
   278 00000129 C3                  <1>   ret
   279                              <1> 
   280                              <1> ; -------------------------------------- Data Segment -------------------------------------------
   281 0000012A 00                  <1> MaxItem       db 0x00                  
   282                              <1> ; used when searching for certain files
   283                              <1> ; ------------------------------------------------------------------------------------------------
   284                              <1> ; 一些基于FAT12头的常量定义
   285                              <1> ; ------------------------------------------------------------------------------------------------
   286                              <1> 
   287                              <1> CFAT12_DrvNum            equ   0
   288                              <1> CFAT12_BytesPerSec       equ   512
   289                              <1> CFAT12_SecPerFAT         equ   9                                            ; number of sectors in each FAT
   290                              <1> CFAT12_SecPerTrk         equ   18                                           ; number of sectors in each Track
   291                              <1> CFAT12_RootSectors       equ   CFAT12_RootEntCnt * CFAT12_RootItemLen / 512 ; number of sectors that contains root items
   292                              <1> CFAT12_SecNoOfRoot       equ   CFAT12_SecNoOfFAT1 + 2 * CFAT12_SecPerFAT    ; index of root directory table's starting location
   293                              <1> CFAT12_SecNoOfFAT1       equ   1                                            ; index of FAT1's starting section
   294                              <1> CFAT12_RootEntCnt        equ   224                                          ; maximal number of items in root directory
   295                              <1> CFAT12_SecNoClstZero     equ   CFAT12_SecNoOfRoot + CFAT12_RootSectors - 2  ; the sector index of cluster 0
   296                              <1>                                                                             ; since the data cluster starts from cluster 2
   297                              <1>                                                                             ; we need to decrease 2 here
   298                              <1> 
   299                              <1> CFAT12_RootItemLen       equ   32
   300                                  %include "print.asm"
   301                              <1> ; print函数在屏幕上显示制定内容
   302                              <1> ; - 以0x0a作为换行符
   303                              <1> ; - 以0x00作为终止符
   304                              <1> ; - 输入字符串的地址由 AX:BX 给出
   305                              <1> 
   306                              <1> ; --------------------------------------- print a string ----------------------------------------
   307                              <1> printstr:
   308 0000012B 50                  <1>   push ax
   309 0000012C 53                  <1>   push bx
   310 0000012D 0FA8                <1>   push gs
   311 0000012F 56                  <1>   push si
   312 00000130 89DE                <1>   mov si, bx
   313 00000132 8EE8                <1>   mov gs, ax
   314                              <1> 
   315                              <1>   printstr_loop:
   316 00000134 658A04              <1>     mov al, [gs:si]
   317 00000137 3C00                <1>     cmp al, 0
   318 00000139 7415                <1>     je printstr_end             ; 若AL = 0 则停止工作. 此处若改为JE entry则可无限向屏幕写入字符串
   319 0000013B 3C0A                <1>     cmp al, 0x0a                ; 处理换行符
   320 0000013D 7506                <1>     jne printstr_noendl
   321 0000013F E8AD00              <1>     call printendl
   322 00000142 46                  <1>     inc si
   323 00000143 EBEF                <1>     jmp printstr_loop
   324                              <1> 
   325                              <1>   printstr_noendl:
   326 00000145 B301                <1>     mov bl, 01                  ; 选择前景色。不过不切换显示模式的话貌似无用
   327 00000147 B40E                <1>     mov ah, 0x0e                ; 选择中断功能：显示字符并后移光标
   328 00000149 CD10                <1>     int 0x10                    ; 调用显示中断
   329 0000014B 83C601              <1>     add si, 1
   330 0000014E EBE4                <1>     jmp printstr_loop
   331                              <1> 
   332                              <1>   printstr_end:
   333 00000150 5E                  <1>     pop si
   334 00000151 0FA9                <1>     pop gs
   335 00000153 5B                  <1>     pop bx
   336 00000154 58                  <1>     pop ax
   337 00000155 C3                  <1>     ret
   338                              <1> 
   339                              <1> ; ----------------------------------------- print number -----------------------------------------
   340                              <1> ; AX/EAX - the word we need to print, e.g. 0x1234
   341                              <1> printsi:
   342 00000156 50                  <1>   push ax
   343 00000157 89F0                <1>   mov ax, si
   344 00000159 E81700              <1>   call printword
   345 0000015C 58                  <1>   pop ax
   346 0000015D C3                  <1>   ret
   347                              <1> 
   348                              <1> printoffset:
   349 0000015E 58                  <1>   pop ax
   350 0000015F 50                  <1>   push ax
   351 00000160 E81000              <1>   call printword
   352 00000163 C3                  <1>   ret
   353                              <1> 
   354                              <1> printdword:
   355 00000164 6650                <1>   push eax
   356 00000166 66C1E810            <1>   shr eax, 16
   357 0000016A E80600              <1>   call printword
   358 0000016D 6658                <1>   pop eax
   359 0000016F E80100              <1>   call printword
   360 00000172 C3                  <1>   ret
   361                              <1> 
   362                              <1> printword:
   363 00000173 53                  <1>   push bx
   364 00000174 51                  <1>   push cx
   365 00000175 50                  <1>   push ax
   366 00000176 89C1                <1>   mov cx, ax
   367 00000178 B300                <1>   mov bl, 0
   368 0000017A B40E                <1>   mov ah, 0x0E
   369                              <1>   ; display 1
   370 0000017C 88E8                <1>   mov al, ch
   371 0000017E C0E804              <1>   shr al, 4
   372 00000181 E82200              <1>   call printword_al2chr
   373 00000184 CD10                <1>   int 0x10
   374                              <1>   ; display 2
   375 00000186 88E8                <1>   mov al, ch
   376 00000188 240F                <1>   and al, 00001111b
   377 0000018A E81900              <1>   call printword_al2chr
   378 0000018D CD10                <1>   int 0x10
   379                              <1>   ; display 3
   380 0000018F 88C8                <1>   mov al, cl
   381 00000191 C0E804              <1>   shr al, 4
   382 00000194 E80F00              <1>   call printword_al2chr
   383 00000197 CD10                <1>   int 0x10
   384                              <1>   ; display 4
   385 00000199 88C8                <1>   mov al, cl
   386 0000019B 240F                <1>   and al, 00001111b
   387 0000019D E80600              <1>   call printword_al2chr
   388 000001A0 CD10                <1>   int 0x10
   389 000001A2 58                  <1>   pop ax
   390 000001A3 59                  <1>   pop cx
   391 000001A4 5B                  <1>   pop bx
   392 000001A5 C3                  <1>   ret
   393                              <1> 
   394                              <1> printword_al2chr:
   395 000001A6 0430                <1>   add al, 0x30
   396 000001A8 3C39                <1>   cmp al, 57
   397 000001AA 7603                <1>   jna printword_al2chr_end
   398 000001AC 0407                <1>     add al, 7
   399 000001AE C3                  <1>     ret
   400                              <1>   printword_al2chr_end:
   401 000001AF C3                  <1>     ret
   402                              <1> 
   403                              <1> ; ----------------------------------------- reset screen -----------------------------------------
   404                              <1> screen_reset:
   405 000001B0 50                  <1>   push ax                        ; store the registers
   406 000001B1 53                  <1>   push bx
   407 000001B2 51                  <1>   push cx
   408 000001B3 52                  <1>   push dx
   409                              <1>   ; step 1. reset color
   410 000001B4 B000                <1>   mov al, 0
   411 000001B6 B73F                <1>   mov bh, 0x3F
   412 000001B8 B90000              <1>   mov cx, 0
   413 000001BB B250                <1>   mov dl, 80                  ; column number of the right below corner
   414 000001BD B619                <1>   mov dh, 25                  ; row number of ....
   415 000001BF B406                <1>   mov ah, 6                   ; function set to `roll up`
   416 000001C1 CD10                <1>   int 0x10                    ; call the interruption
   417                              <1>   ; step 2. reset position
   418 000001C3 B402                <1>   mov ah, 2                   ; reset cursor
   419 000001C5 B700                <1>   mov bh, 0                   ; page number = 0
   420 000001C7 BA0000              <1>   mov dx, 0                   ; position reset as dh = 0, dl = 0
   421 000001CA CD10                <1>   int 0x10
   422 000001CC 5A                  <1>   pop dx
   423 000001CD 59                  <1>   pop cx
   424 000001CE 5B                  <1>   pop bx
   425 000001CF 58                  <1>   pop ax
   426 000001D0 C3                  <1>   ret
   427                              <1> 
   428                              <1> ; ------------------------------------------------------------------------------------------------
   429                              <1> printspace:
   430 000001D1 53                  <1>   push bx
   431 000001D2 50                  <1>   push ax
   432 000001D3 B300                <1>   mov bl, 0
   433 000001D5 B40E                <1>   mov ah, 0x0E
   434 000001D7 B020                <1>   mov al, ' '
   435 000001D9 CD10                <1>   int 0x10
   436 000001DB 58                  <1>   pop ax
   437 000001DC 5B                  <1>   pop bx
   438 000001DD C3                  <1>   ret
   439                              <1> 
   440                              <1> printhexhead:
   441 000001DE 53                  <1>   push bx
   442 000001DF 50                  <1>   push ax
   443 000001E0 B300                <1>   mov bl, 0
   444 000001E2 B40E                <1>   mov ah, 0x0E
   445 000001E4 B030                <1>   mov al, '0'
   446 000001E6 CD10                <1>   int 0x10
   447 000001E8 B078                <1>   mov al, 'x'
   448 000001EA CD10                <1>   int 0x10
   449 000001EC 58                  <1>   pop ax
   450 000001ED 5B                  <1>   pop bx
   451 000001EE C3                  <1>   ret
   452                              <1> 
   453                              <1> ; endl 的机制：
   454                              <1> ; - 读取当前光标位置
   455                              <1> ; - 重设光标位置，令行数+1，列数清零
   456                              <1> printendl:
   457 000001EF 53                  <1>   push bx
   458 000001F0 50                  <1>   push ax
   459                              <1>   ; 调取当前光标
   460 000001F1 B700                <1>   mov bh, 0
   461 000001F3 B403                <1>   mov ah, 3
   462 000001F5 CD10                <1>   int 0x10
   463                              <1>   ; 重写当前光标
   464 000001F7 FEC6                <1>   inc dh
   465 000001F9 B200                <1>   mov dl, 0
   466 000001FB B402                <1>   mov ah, 2
   467 000001FD CD10                <1>   int 0x10
   468 000001FF 58                  <1>   pop ax
   469 00000200 5B                  <1>   pop bx
   470 00000201 C3                  <1>   ret
   471                                  ; ---------------------------------------- 数据段 ------------------------------------------------
   472 00000202 426F6F74204C6F6164-     LoaderReadyStr    db  "Boot Loader online, trying to locate the kernel ... ", 0x00
   473 0000020B 6572206F6E6C696E65-
   474 00000214 2C20747279696E6720-
   475 0000021D 746F206C6F63617465-
   476 00000226 20746865206B65726E-
   477 0000022F 656C202E2E2E2000   
   478 00000237 444F4E452E0A00          KernelReadyStr    db  "DONE.", 0x0a, 0x00
   479 0000023E 4B45524E454C2020        KernelName        db  "KERNEL  "
